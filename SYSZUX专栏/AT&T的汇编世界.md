# 背景
本文很久之前（2010年左右）由Gemfield发表于CivilNet Blog，2017年的时候CivilNet Blog停止服务，于是gemfield迁移本文至此。

x86汇编语法主要有两种：Intel和AT&T，不管是gcc使用的gas（GNU assembler），还是llvm自己的汇编器，默认产生的文本形式汇编指令都是AT&T语法的。这原因大概就是AT&T的贝尔实验室在整整50年前发明了UNIX操作系统。

# 寄存器
在汇编世界里，我们主要通过汇编指令来操纵两种东西：

- 寄存器
- 内存地址

熟悉以上两种东西将极大的方便我们对汇编的理解，这个章节里Gemfield就来说说寄存器吧。

## 1，寄存器的位数
由于x86-64架构惊人的后向兼容性，同一个寄存器，我们可以使用其中的8bit、16bit、32bit、64bit，以ax寄存器为例，分别是ah/al、ax、eax、rax，如下图所示：
![v2-aaffcd4d6be1fc87eebf21aacba6f76d_720w](https://github.com/user-attachments/assets/a860412f-db04-4a5a-947f-2826f65a8cac)

这就导致一个问题，从大的寄存器上往小的寄存器上mov没有问题，而从小的寄存器往大的寄存器上mov就需要使用movsxd或者movsx指令了：
![v2-45b3136b2500cf0ee9a9e9c47a7031bc_720w](https://github.com/user-attachments/assets/0c7f8f88-be51-4cfd-8bbe-42a479fe9365)

## 2，通用寄存器
寄存器有两种概念，逻辑上的和物理上的，分别是架构相关寄存器（architectural register）和物理寄存器（physical register）。前者是指令集（ISA）提供给编译器可见的，相当于API接口规范，一共16个通用寄存器；后者是硬件上实际设计的，软件领域不直接接触。最新的CPU可能有上百个实际的物理寄存器。当然了，对软件开发人员来说，我们只需要关注逻辑上的通用寄存器。

这16个逻辑上的通用寄存器如下所示：
![截屏2025-03-13 16 23 29](https://github.com/user-attachments/assets/1f54dae8-5954-40e0-9dc0-816366e3c442)

# 指令
在本章节，Gemfield将介绍如下概念：

- 前缀、操作数的方向、操作码的后缀；
- 运算指令；
- 拷贝指令；
- 流程控制指令。

## 1，前缀、操作数的方向、操作码的后缀
关于前缀，AT&T 汇编中：

- 寄存器前被冠以“%”
- 立即数前被冠以“$”
- 十六进制数前被冠以“0x”

所以，如果gemfield在AT&T 语境中说到386的通用寄存器时，会这样描述：8个32-bit寄存器 %eax，%ebx，%ecx，%edx，%edi，%esi，%ebp，%esp。比如：在stage1.s中，有这么一个定义：
```c
#define ABS(x) （x-_start+0x7c00）
```
那么你就会知到0x7c00是个十六进制数（_start函数的入口地址就位于内存的0x7c00处）。而在设置int 0x13的0x42功能号时，它是这么说的：
```c
movb $0x42,%ah
```
这句告诉了我们一些不同之处：

- 首先，操作码的后缀l表示的是操作码的大小，l是长整数32位，那么相应的，movw是16位，movb是8位；
- 其次，立即数是用$前缀来表示的，就像$0x42；再次，寄存器的名字是有%前缀的，像例子中的%ah；
- 最后，操作数的方向有点不一样，比如把立即数$0x42放 到寄存器%ah中，用的是movb $0x42,%ah，也即源操作数在前，目的操作数在后，这一点和intel汇编语法正好相反。

对于内存单元操作数来说，在AT&T 中是把寄存器用（）括起来，而非[]。比如：
```c
movl %ebx,8（%si）
```
将ebx寄存器里的值放到内存地址是8（%si）的内存单元上。正好，这里同时遇到了另一个问题，就是在AT&T 汇编中，间接寻址方式是有别于intel汇编的。上例中的8（%si）就相当于intel汇编中的[si+8]。

## 2，运算指令
Gemfield列举一些常见的命令：

- add %r10,%r11    // r10 + r11，结果放到r11
- add $5,%r10      //  5 + r10，结果放到r10
- div %r10         // rax 除以r10，商放到rax，余数放到rdx
- inc %r10         //  r10 加1
- mul %r10         // 将rax乘以 r10, 将结果放到rax中，溢出部分放到rdx 

## 3，拷贝指令
这些拷贝有从寄存器到寄存器、从寄存器到内存

- mov %r10,%r11    //将r10寄存器的值赋值给r11 ；
- mov $99,%r10     //将立即数99赋值给r10寄存器；
- mov %r10,(%r11)  // 将r10的值拷贝到r11寄存器中的数值指向的内存地址上；
- mov (%r10),%r11  // 将r10中数值指向的内存地址上的内容拷贝到r11；
- push %r10        // 将r10的值放到栈上 ；
- pop %r10         // 将栈顶的值pop到r10寄存器上。

## 4，流程控制指令
还有一种叫做label（标号）的程序控制语句，比如，在stage1.s中，有这么一段指令：
```c
cmpb $GRUB_INVALID_DRIVE,%al
    je 1f
    movb %al,%dl
1:
    pushw %dx
```
上面就用到了标号，je 1f，前面的两个数进行比较，如果相等就跳转到1的位置。注意，1后面的f表示的是forward，即从je指令后继续往前走来寻找1这个标号。所以，如果程序中有好几个叫做1的标号，就要看是1f还是1b了，b代表backward，方向和f相反。CivilNet BBS里有这么一个例子可以更好的帮助我们理解：
```c
1:    cmp  $0,  (%si)  
      je  1f            ///////跳转到后面的1标示的地方，也就是第6行
      movsb  
      stosb  
      jmp  1b       ////////跳转到前面1表示的地方  ，也就是第1行
1:    jmp  1b        ////////跳转到前面1表示的地方，第6行，其实就是个死循环
```
```c
    cmp %r10,%r11    // 比较r10 和 r11，根据比较结果来设置CPU的状态寄存器，从而影响后面的jump语句；
    cmp $99,%r11     // 比较99和r11，根据比较结果来设置CPU的状态寄存器，从而影响后面的jump语句；
    jmp label        //跳转到label 
    je  label        //如果相等，跳转到label 
    jne label        // 如果不相等，跳转到label 
    jl  label        // 如果小于，跳转到label 
    jg  label        // 如果大于，跳转到label 
    call label       // 调用函数
    ret              // 从函数调用返回
    syscall          //系统调用 (32位模式下, 使用"int $0x80" 软中断)
```
# assembler directive
在AT&T 汇编中出现最多的大概就是称作assembler directive的东西了，我们称作“AT&T 汇编指示符”。 所有的汇编指示符都由句号（'.'）开头。命令名的其余是字母,通常使用小写。下面gemfield挑出几个常用的来说明一下:

## 1，.byte 表达式（expression_rs）
.byte可不带参数或者带多个表达式参数，表达式之间由逗点分隔。每个表达式参数都被汇编成下一个字节。在stage1.s中，有这么一段代码：
```c
after_BPB:
CLI
.byte 0x80,0xca
```
那么编译器在编译时，就会在cli指令的下面接着放上0x80和0xca，因为每个表达式要占用1个字节，所以此处一共占用2个字节。
## 2，.word 表达式
这个表达式表示任意一节中的一个或多个表达式（同样用逗号分开），表达式占一个字（两个字节）。类似的还有.long。例：
```c
.word 0x800
```
## 3，.file 字符（string）
.file 通告编译器我们准备开启一个新的逻辑文件。 string 是新文件名。总的来说，文件名是否使用引号‘"’都可以；但如果您希望规定一个空文件名时，必须使用引号""。本语句将来可能不再使用—允许使用它只是为了与旧版本的as编译器程序兼容。在as的一些配置中，已经删除了.file以避免与其它的汇编器冲突。例如stage1.s中：
```c
.file ”stage1.s”
```
## 4，.text 小节（subsection）
通知as编译器把后续语句汇编到编号为subsection的正文子段的末尾，subsection是一个纯粹的表达式。如果省略了参数subsection，则使用编号为0的子段。例：
```c
.text
```
## 5，.code16
告诉编译器生成16位的指令
## 6，.globl
.globl使得连接程序（ld）能够看到symbol，如果gemfield在局部程序中定义了symbol，那么与这个局部程序链接的局部程序也能存取symbol，例：
```c
.globl SYMBOL_NAME(idt) 
```
定义idt为全局符号。
## 7，.fill repeat , size , value
repeat, size 和value都必须是纯粹的表达式。本命令生成size个字节的repeat个副本。Repeat可以是0或更大的值。Size 可以是0或更大的值, 但即使size大于8,也被视作8，以兼容其它的汇编器。各个副本中的内容取自一个8字节长的数。最高4个字节为零，最低的4个字节是value，它以as正在汇编的目标计算机的整数字节顺序排列。每个副本中的size个字节都取值于这个数最低的size个字节。再次说明，这个古怪的动作只是为了兼容其他的汇编器。size参数和value参数是可选的。如果不存在第2个逗号和value参数，则假定value为零。如果不存在第1个逗号和其后的参数，则假定size为1。

例如，在linux初始化的过程中，对全局描述符表GDT进行设置的最后一句为：
```c
.fill NR_CPUS*4,8,0
```
意思是.fill给每个cpu留有存放4个描述符的位置，并且每个描述符是8个字节。不过要注意的是，这种包含程序已初始化数据的节（.data）和包含程序程序还未初始化的数据的节（.bss），编译器会把它们在4字节上对齐，例如，.data是25字节，那么编译器会将它放在28个字节上。当这种以后缀名.s编写的A T&T格式的汇编代码完成后，就是编译和链接了。
## 链接
linux下有两种方式，一种是使用汇编程序GAS和链接程序ld：
```bash
as filename.s –o filename.o
ld filename.o –o filename 
```
最终将源代码转换为目标文件.o再连接为可执行文件filename。另一种就是更上层的gcc（内部使用了as）：
```bash
gcc –o gemfield gemfield.S
```
源程序gemfield.S的后缀名可以使用大写，是因为这样可以使gcc自动识别汇编程序中的c预处理命令，包括头文件中的情况，像#include、#define 、#ifdef等。
# 最后
如果想要真正实践一下这种汇编，grub源代码stage1.s就是一个绝佳的习题。
